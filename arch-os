#!/usr/bin/env bash
# shellcheck disable=SC1090

set -Eeo pipefail

# ///////////////////////////////////////////////////////////////////
#                         ARCH OS MANAGER
#                - Arch Linux Helper Script TUI -
# ///////////////////////////////////////////////////////////////////

# SOURCE:   https://github.com/murkl/arch-os-manager
# AUTOR:    murkl
# ORIGIN:   Germany
# LICENCE:  GPL 2.0

# SCRIPT VERSION
VERSION="1.6.9"

# ENVIRONMENT
: "${KITTY:=/usr/bin/kitty}"
: "${GUM:=/usr/bin/gum}"

# HOME
ARCH_OS_HOME="${HOME}/.arch-os"

# CONFIG
ARCH_OS_CONF="${ARCH_OS_HOME}/config/settings.conf"
ARCH_OS_BLACKLIST="${ARCH_OS_HOME}/config/blacklist.conf"
ARCH_OS_KITTY_CONF="${ARCH_OS_HOME}/config/kitty.conf"

# DATABASE
PACKAGES_DB="${ARCH_OS_HOME}/database/packages.db"
NEWS_DB="${ARCH_OS_HOME}/database/news.db"
UPDATES_DB="${ARCH_OS_HOME}/database/updates.db"
STATE_DB="${ARCH_OS_HOME}/database/state.db"

# TEMP
ARCH_OS_TMP="$(mktemp -d "/tmp/arch-os.XXXXXXX")"
MIRRORLIST_TMP="${ARCH_OS_TMP}/mirrorlist"

# STATE
HEADER_PRINTED="false"

# GUM COLORS (https://github.com/muesli/termenv?tab=readme-ov-file#color-chart)
COLOR_PURPLE=212
COLOR_WHITE=7

# BASH COLORS
COLOR_RESET_BASH="\033[0m"
COLOR_BOLD_BASH="\033[1m"
COLOR_WHITE_BASH="\033[37m"
COLOR_RED_BASH="\033[31m"
COLOR_GREEN_BASH="\033[32m"
COLOR_YELLOW_BASH="\033[33m"

# ///////////////////////////////////////////////////////////////////
# MAIN FUNCTION
# ///////////////////////////////////////////////////////////////////

main() {

    # Init properties
    init_properties

    # Install
    [ "$1" = '--install' ] && {
        install_script_dependencies && exit 0
        exit 1
    }

    # Check dependencies
    if ! command -v "$GUM" &>/dev/null; then echo "ERROR: gum not found. Install with: sudo pacman -S gum" >&2 && exit 1; fi
    if ! command -v "$KITTY" &>/dev/null; then echo "ERROR: kitty not found. Install with: sudo pacman -S kitty" >&2 && exit 1; fi
    if ! command -v /usr/bin/checkupdates &>/dev/null; then echo "ERROR: checkupdates not found. Install with: sudo pacman -S pacman-contrib" >&2 && exit 1; fi
    if ! command -v /usr/bin/notify-send &>/dev/null; then echo "ERROR: notify-send not found. Install with: sudo pacman -S libnotify" >&2 && exit 1; fi

    # Set Traps
    trap 'trap_error $? ${FUNCNAME} ${LINENO}' ERR # Set error trap
    trap 'trap_exit $?' EXIT                       # Set exit trap

    # Init state & init properties
    init_state && persist_properties

    # Sync database & exit
    if [ "$1" = '--sync' ]; then
        if shift && [ $# -eq 0 ]; then
            sync_news_db
            sync_package_db
            sync_updates_db
            exit 2
        fi
        for arg in "$@"; do
            case "$arg" in
            'news') sync_news_db ;;
            'packages') sync_package_db ;;
            'updates') sync_updates_db ;;
            *) exit 3 ;;
            esac
        done
        exit 2
    fi

    # Start kitty & exit
    if [ "$1" = '--kitty' ] || [ "$1" = '-k' ]; then
        shift # Shift argument to next
        # Start kitty if not already present
        if [ "$TERM" != "xterm-kitty" ]; then
            kitty "$SELF" "$@" # Open script in kitty instance
            exit 2
        fi
    fi

    # Check number of user arguments
    if [ $# -gt 1 ]; then
        print_header && show_help && echo && print_fail "Max. 1 argument supported!" && gum_confirm_continue
        exit 3
    fi

    # User action argument
    local user_action="$1"

    # -------------------------------------------------------------------

    while (true); do

        # Show menu if user action argument is NOT set
        local selected_action && if [ -z "$user_action" ]; then
            local user_input options
            clear_screen && print_header
            options=("Dashboard" "Packages" "Upgrade" "Actions" "Config" "Help" "Quit")
            user_input=$(gum_choose --cursor "> " --height=10 --selected="$user_input" "${options[@]}") || { clear_screen && exit 2; }
            case "$user_input" in # Set user action to selected action
            'Dashboard') selected_action='dashboard' ;;
            'Upgrade') selected_action='upgrade' ;;
            'Actions')
                clear_screen && print_header
                options=("Update Information" "Remove Orphans" "Merge Configurations" "Refresh Mirrorlist" "Downgrade Packages" "Clear Cache" "Reset Pacman" "Back")
                user_input2=$(gum_choose --cursor "> " --height=11 --selected="$user_input2" "${options[@]}") || continue
                case "$user_input2" in # Set user action to selected action
                'Update Information') selected_action='info' ;;
                'Remove Orphans') selected_action='orphans' ;;
                'Merge Configurations') selected_action='merge' ;;
                'Refresh Mirrorlist') selected_action='refresh' ;;
                'Downgrade Packages') selected_action='downgrade' ;;
                'Clear Cache') selected_action='cache' ;;
                'Reset Pacman') selected_action='reset' ;;
                'Back') continue ;;
                esac
                ;;
            'Packages') selected_action='pkg' ;;
            'Config') selected_action='config' ;;
            'Help') selected_action='help' ;;
            'Quit') clear_screen && exit 2 ;;
            esac
        fi

        # Set if user arg is available and no menu was shown
        [ -z "$selected_action" ] && selected_action="$user_action"

        # Execute action
        local skip_confirm="false"
        case "$selected_action" in # Execute action
        'pkg') { print_header && show_search; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'dashboard') { print_header && show_dashboard; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'info') { print_header && show_update_info --no-sync; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'upgrade') { print_header && show_upgrade; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'orphans') { print_header && show_orphans; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'merge') { print_header && show_merge; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'refresh') { print_header && show_refresh; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'downgrade') { print_header && show_downgrade; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'cache') { print_header && show_clear_cache; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'reset') { print_header && show_reset_pacman; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'config') { print_header && show_config; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'help') { print_header && show_help; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'version') { print_header && show_version; } || { ret=$? && { [ "$ret" = 2 ]; } && skip_confirm="true"; } ;;
        'notify') action_notify_updates || { ret=$? && { [ "$ret" = 2 ] || [ "$ret" = 3 ]; } && skip_confirm="true"; } ;;
        'check') action_check_updates_available || { ret=$? && { [ "$ret" = 2 ] || [ "$ret" = 3 ]; } && skip_confirm="true"; } ;;
        *) print_header && show_help && echo && print_fail "Action '${selected_action}' not available!" ;;
        esac

        # Cleanup run (order is important!)
        unset selected_action
        [ -n "$user_action" ] && [ "$skip_confirm" = "true" ] && exit 2                                 # User arg IS avaiable & skip confirm -> exit
        [ -z "$user_action" ] && [ "$skip_confirm" = "true" ] && continue                               # User arg NOT available & skip confirm -> continue
        [ -z "$user_action" ] && [ "$skip_confirm" = "false" ] && { gum_confirm_continue || continue; } # User arg NOT available & confirm is canceled -> continue
        [ -n "$user_action" ] && [ "$skip_confirm" = "false" ] && gum_confirm_continue                  # User arg IS avaiable -> continue
        [ -n "$user_action" ] && exit 2                                                                 # User arg IS avaiable -> exit
    done
}

# ///////////////////////////////////////////////////////////////////
# TRAP FUNCTIONS
# ///////////////////////////////////////////////////////////////////

# RETURN CODES
#   0 : success (confirm)
#   1 : error   (confirm)
#   2 : success (no confirm)
#   3 : error   (no confirm)
# 130 : cancel  (no confirm)

trap_exit() {
    rm -rf "$ARCH_OS_TMP"
    [ "$1" != 2 ] && [ "$1" != 3 ] && [ "$1" != 130 ] && gum_confirm_continue
    [ "$1" = 2 ] && exit 0 # Exit with 0 if return code is 2
    exit "$1"
}

trap_error() {
    [ "$1" != 2 ] && [ "$1" != 3 ] && [ "$1" != 130 ] && print_fail "${BASH_COMMAND} failed ($1) in function '${2}' (line ${3})"
    return "$1"
}

# ///////////////////////////////////////////////////////////////////
# STATE FUNCTIONS
# ///////////////////////////////////////////////////////////////////

init_state() {
    touch "$STATE_DB" && source "$STATE_DB" && persist_state && return 0
    return 1
}

persist_state() {
    { # Write state.db
        echo "LATEST_UPDATE_CHECK=\"${LATEST_UPDATE_CHECK}\""
        echo "LATEST_SYSTEM_UPGRADE=\"${LATEST_SYSTEM_UPGRADE}\""
        echo "LATEST_ARCH_LINUX_NEWS_DATE=\"${LATEST_ARCH_LINUX_NEWS_DATE}\""
    } >"$STATE_DB" && return 0
    return 1
}

print_timestamp() { date +"%Y-%m-%d %H:%M:%S"; }

# ///////////////////////////////////////////////////////////////////
# PROPERTIES FUNCTIONS
# ///////////////////////////////////////////////////////////////////

init_properties() {

    # Create working dirs
    mkdir -p "$ARCH_OS_HOME"
    mkdir -p "$ARCH_OS_TMP"
    mkdir -p "${ARCH_OS_HOME}/config"
    mkdir -p "${ARCH_OS_HOME}/database"
    mkdir -p "${HOME}/.config/autostart"

    # Migrate: < 1.5.5
    [ -f "${ARCH_OS_HOME}/arch-os.conf" ] && mv -f "${ARCH_OS_HOME}/arch-os.conf" "${ARCH_OS_HOME}/settings.conf"
    [ -f "${ARCH_OS_HOME}/kitty.conf" ] && mv -f "${ARCH_OS_HOME}/kitty.conf" "${ARCH_OS_HOME}/config/kitty.conf"
    [ -f "${ARCH_OS_HOME}/packages.db" ] && mv -f "${ARCH_OS_HOME}/packages.db" "${ARCH_OS_HOME}/database/packages.db"
    [ -f "${ARCH_OS_HOME}/news.db" ] && mv -f "${ARCH_OS_HOME}/news.db" "${ARCH_OS_HOME}/database/news.db"

    # Migrate: < 1.5.7
    [ -f "${ARCH_OS_HOME}/settings.conf" ] && mv -f "${ARCH_OS_HOME}/settings.conf" "${ARCH_OS_HOME}/config/settings.conf"

    # -------------------------------------------------------------------

    # Source config
    touch "$ARCH_OS_CONF"
    source "$ARCH_OS_CONF"

    # Create blacklist.conf
    touch "$ARCH_OS_BLACKLIST"

    # Set default properties
    [ -z "$AUTOSTART_NOTIFY" ] && AUTOSTART_NOTIFY="true"
    [ -z "$AUTOSTART_DELAY" ] && AUTOSTART_DELAY="60"
    [ -z "$AUR_MANGER_REPO" ] && AUR_MANGER_REPO="paru"
    [ -z "$AUR_SUPPORT" ] && command -v /usr/bin/paru &>/dev/null && AUR_SUPPORT="true"
    [ -z "$AUR_REVIEW" ] && AUR_REVIEW="false"
    [ -z "$ARCH_UPGRADE_CONFIRM" ] && ARCH_UPGRADE_CONFIRM="true"
    [ -z "$ARCH_DOWNLOAD_TIMEOUT" ] && ARCH_DOWNLOAD_TIMEOUT="false"
    [ -z "$FLATPAK_SUPPORT" ] && command -v /usr/bin/flatpak &>/dev/null && FLATPAK_SUPPORT="true"
    [ -z "$FLATPAK_UPGRADE_CONFIRM" ] && FLATPAK_UPGRADE_CONFIRM="false"
    [ -z "$NEWS_QUANTITY" ] && NEWS_QUANTITY="3"
    [ -z "$ORPHANS_CONFIRM" ] && ORPHANS_CONFIRM="false"
    [ -z "$SHOW_SYSTEM_LOG" ] && SHOW_SYSTEM_LOG="true"
    [ -z "$SHOW_SERVICE_LIST" ] && SHOW_SERVICE_LIST="true"
    [ -z "$SHOW_USER_SERVICES" ] && SHOW_USER_SERVICES="false"
    [ -z "$SHOW_UNKNOWN_PKG_LIST" ] && SHOW_UNKNOWN_PKG_LIST="false"

    return 0
}

persist_properties() {

    # Validate properties
    [ "$AUTOSTART_DELAY" -gt 500 ] && AUTOSTART_DELAY="500" # Set to max 500
    [ "$AUTOSTART_DELAY" -lt 10 ] && AUTOSTART_DELAY="10"   # Set to min 10
    [ "$NEWS_QUANTITY" -gt 10 ] && NEWS_QUANTITY="10"       # Set to max 10
    [ "$NEWS_QUANTITY" -lt 0 ] && NEWS_QUANTITY="0"         # Set to min 0

    # Check AUR binary
    if [ "$AUR_SUPPORT" = "true" ]; then
        local error && unset error
        [ -z "$error" ] && ! command -v /usr/bin/paru &>/dev/null && error="/usr/bin/paru not found"
        [ -z "$error" ] && ! /usr/bin/paru --version &>/dev/null && error="/usr/bin/paru is not working"
        [ -n "$error" ] && {
            print_fail "$error"
            notify_send "Error" "$error"
            ! gum_confirm --timeout=3s "Disable AUR_SUPPORT?" && print_fail "Canceled" && exit 3
            AUR_SUPPORT="false" && print_warn "AUR_SUPPORT was disabled"
        }

    fi

    # Check Flatpak binary
    if [ "$FLATPAK_SUPPORT" = "true" ]; then
        local error && unset error
        [ -z "$error" ] && ! command -v /usr/bin/flatpak &>/dev/null && error="/usr/bin/flatpak not found"
        [ -z "$error" ] && ! /usr/bin/flatpak --version &>/dev/null && error="/usr/bin/flatpak is not working"
        [ -n "$error" ] && {
            print_fail "$error"
            notify_send "Error" "$error"
            ! gum_confirm --timeout=3s "Disable FLATPAK_SUPPORT?" && print_fail "Canceled" && exit 3
            FLATPAK_SUPPORT="false" && print_warn "FLATPAK_SUPPORT was disabled"
        }
    fi

    # Toggle settings
    if [ "$AUTOSTART_NOTIFY" = "true" ]; then
        {
            echo "[Desktop Entry]"
            echo "Type=Application"
            echo "Name=Arch OS Manager"
            echo "Icon=${WORKING_DIR}/docs/logo.svg"
            echo "Exec=bash -c 'sleep ${AUTOSTART_DELAY} && ${SELF} notify'"
        } >"${HOME}/.config/autostart/arch-os.desktop"
    else
        rm -f "${HOME}/.config/autostart/arch-os.desktop"
    fi

    { # Write properties
        echo "ARCH_UPGRADE_CONFIRM=${ARCH_UPGRADE_CONFIRM}"
        echo "ARCH_DOWNLOAD_TIMEOUT=${ARCH_DOWNLOAD_TIMEOUT}"
        echo "AUR_MANGER_REPO=${AUR_MANGER_REPO}"
        echo "AUR_SUPPORT=${AUR_SUPPORT}"
        echo "AUR_REVIEW=${AUR_REVIEW}"
        echo "FLATPAK_SUPPORT=${FLATPAK_SUPPORT}"
        echo "FLATPAK_UPGRADE_CONFIRM=${FLATPAK_UPGRADE_CONFIRM}"
        echo "ORPHANS_CONFIRM=${ORPHANS_CONFIRM}"
        echo "AUTOSTART_NOTIFY=${AUTOSTART_NOTIFY}"
        echo "AUTOSTART_DELAY=${AUTOSTART_DELAY}"
        echo "NEWS_QUANTITY=${NEWS_QUANTITY}"
        echo "SHOW_SYSTEM_LOG=${SHOW_SYSTEM_LOG}"
        echo "SHOW_SERVICE_LIST=${SHOW_SERVICE_LIST}"
        echo "SHOW_USER_SERVICES=${SHOW_USER_SERVICES}"
        echo "SHOW_UNKNOWN_PKG_LIST=${SHOW_UNKNOWN_PKG_LIST}"
    } >"$ARCH_OS_CONF"

    # Source again
    source "$ARCH_OS_CONF"
}

# ///////////////////////////////////////////////////////////////////
# DATABASE FUNCTIONS
# ///////////////////////////////////////////////////////////////////

sync_updates_db() {

    # Remove database tmp file
    mkdir -p "${ARCH_OS_TMP}"
    local tmp_db="${ARCH_OS_TMP}/update.db.tmp"
    rm -f "$tmp_db"
    touch "$tmp_db"

    # Pacman updates
    while timeout 30 tail --pid=$(pgrep checkupdates) -f /dev/null &>/dev/null; do sleep 1; done
    pgrep checkupdates &>/dev/null && print_fail "Timeout after 30 seconds" && exit 3

    while IFS= read -r line; do
        [ -n "$line" ] && echo "$line" | sed 's/\x1b\[[0-9;]*m//g' | awk '{print "pacman," $1 "," $2 "," $4}' >>"$tmp_db"
    done < <(/usr/bin/checkupdates || echo)

    # AUR updates
    if [ "$AUR_SUPPORT" = 'true' ] && /usr/bin/paru -Qua &>/dev/null; then
        while read -r line; do
            [ -n "$line" ] && echo "$line" | sed 's/\x1b\[[0-9;]*m//g' | awk '{print "aur," $1 "," $2 "," $4}' >>"$tmp_db"
        done < <(/usr/bin/paru -Qua)
    fi

    # Flatpak updates
    if [ "$FLATPAK_SUPPORT" = "true" ]; then
        while read -r line; do
            [ -n "$line" ] && echo "$line" | awk '{print "flatpak," $1 "," $2 "," ($3 == "" ? "latest" : $3)}' >>"$tmp_db"
        done < <(flatpak remote-ls --updates --columns=application,version,branch | tail -n +1)
    fi

    # Perists update.db
    mv -f "$tmp_db" "$UPDATES_DB"

    # Persist state
    LATEST_UPDATE_CHECK="$(print_timestamp)" && persist_state
    return 0
}

sync_news_db() {
    if [ -n "$NEWS_QUANTITY" ] && [ "$NEWS_QUANTITY" -gt 0 ]; then

        # Helper functions
        print_news_date() { echo -n "$(<"$tmp_db")" | xmllint --xpath "string(//item[$1]/pubDate)" - | date -f - "+%Y/%m/%d"; }
        print_news_title() { echo -n "$(<"$tmp_db")" | xmllint --xpath "string(//item[$1]/title)" -; }
        print_news_url() { echo -n "$(<"$tmp_db")" | xmllint --xpath "string(//item[$1]/link)" - | awk '{$1=$1; print}'; }

        # Fetch news from internet
        mkdir -p "${ARCH_OS_TMP}"
        local tmp_db="${ARCH_OS_TMP}/news.db.tmp"
        curl -sf https://archlinux.org/feeds/news/ >"$tmp_db"

        # Add latest 10 (max) news in db
        local news_list=()
        for ((i = 1; i <= 10; i++)); do
            news_list+=("$(print_news_date "$i");$(print_news_url "$i");$(print_news_title "$i");")
        done

        # Persist news db
        printf '%s\n' "${news_list[@]}" >"$NEWS_DB"
    fi
    return 0
}

sync_package_db() {
    local tmp_db_default="${ARCH_OS_TMP}/packages-pac.db"
    local tmp_db_aur="${ARCH_OS_TMP}/packages-aur.db"
    ! /usr/bin/pacman -Slq >"$tmp_db_default" && return 3

    # Add AUR packages
    if [ "$AUR_SUPPORT" = "true" ]; then
        /usr/bin/paru -Slqa >"$tmp_db_aur" || rm -f "$tmp_db_aur"
        [ -f "$tmp_db_aur" ] && cat "$tmp_db_aur" >>"$tmp_db_default"
    fi

    # Sort and remove redundant entries
    #sort "$tmp_db_default" | uniq >"${tmp_db_default}.trim"
    sort "$tmp_db_default" >"${tmp_db_default}.trim"
    mv -f "${tmp_db_default}.trim" "$PACKAGES_DB"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# ACTION FUNCTIONS
# ///////////////////////////////////////////////////////////////////

action_check_updates_available() { # Check & print package updates
    # Check if updates available
    sync_updates_db && [ ! -s "$UPDATES_DB" ] && return 3
    # Print updates in checkupdates format (g = green | b = bold | r = reset)
    while IFS=',' read -r manager package_name current_version new_version; do
        echo "${package_name} ${current_version} ${new_version}" |
            awk -v r="$(tput sgr0 2>/dev/null)" \
                -v b="$(tput bold 2>/dev/null)" \
                -v g="$(tput setaf 2 2>/dev/null)" \
                '{ printf "%s%s%s %s%s%s%s -> %s%s%s%s\n", 
                    b, $1, r,     # Package
                    b, g, $2, r,  # Current version
                    b, g, $3, r   # New version
                 }'
    done <"$UPDATES_DB"
    return 2
}

# -------------------------------------------------------------------

action_notify_updates() { # Notify on new updates
    local update_result notify_result update_count update_txt
    update_result="$(action_check_updates_available)" || true
    update_count=0 && [ -n "$update_result" ] && update_count=$(echo "$update_result" | wc -l)
    echo "$update_result"
    if [ "$update_count" -gt 0 ]; then
        [ "$update_count" = 1 ] && update_txt="<b>${update_count}</b> Update available"
        [ "$update_count" -gt 1 ] && update_txt="<b>${update_count}</b> Updates available"
        notify_result=$(
            notify-send \
                -a "Arch OS Manager" \
                -i "${WORKING_DIR}/docs/logo.svg" \
                -u critical \
                -c device.added \
                -h string:sound-name:message-new-instant \
                -A "info=Update Info" \
                -A "upgrade=Run Upgrade" \
                "System Upgrade" \
                "${update_txt}"
        )
        [ "$notify_result" = "info" ] && ${SELF} -k info
        [ "$notify_result" = "upgrade" ] && ${SELF} -k upgrade
        return 2
    fi
    return 3
}

# ///////////////////////////////////////////////////////////////////
#  PRINT INFO FUNCTIONS
# ///////////////////////////////////////////////////////////////////

print_no_internet_info() {
    for i in {1..3}; do
        timeout 5 ping -c 1 -W 2 8.8.8.8 &>/dev/null && return 0
        sleep 2
    done
    print_fail "No Internet Connection" && return 3
}

# -------------------------------------------------------------------

print_system_error_logs() { journalctl -p 3 -b --quiet --no-pager | grep -E '^[A-Za-z]{3} [ 0-9]{1,2} [0-9:]{8} ' | grep -vf <(awk 'NF' "$ARCH_OS_BLACKLIST"); }
print_service_running() {
    systemctl list-units --type=service --state=running --plain --no-legend | while read -r line; do print_format_green 0 "SYS (running)" "${line%% *}"; done
    [ "$SHOW_USER_SERVICES" = "true" ] && systemctl --user list-units --type=service --state=running --plain --no-legend | while read -r line; do print_format_green 0 "USR (running)" "${line%% *}"; done
    return 0
}
print_service_failed() {
    if systemctl --failed | grep -q 'failed'; then systemctl --failed --quiet | while read -r line; do print_format_red 0 "SYS (running)" "$(echo "${line//● /}" | awk '{print $1}')"; done; fi
    [ "$SHOW_USER_SERVICES" = "true" ] && if systemctl --user --failed | grep -q 'failed'; then systemctl --user --failed --quiet | while read -r line; do print_format_red 0 "USR (running)" "$(echo "${line//● /}" | awk '{print $1}')"; done; fi
    return 0
}

# -------------------------------------------------------------------

show_news_info() { # Show Arch Linux News
    if [ -n "$NEWS_QUANTITY" ] && [ "$NEWS_QUANTITY" -gt 0 ] && print_title "Arch Linux News"; then

        # Helper
        print_news_value() { awk -F';' -v ln="$1" -v cn="$2" 'NR == ln {print $cn; exit}' "$NEWS_DB"; }

        # Sync db
        print_no_internet_info || return 3
        ! gum_spin --title 'Synchronize News Database...' -- bash -c "${SELF} --sync news" && print_fail "Synchronize Database (news) failed" && return 3

        # Check unread news
        local unread_news="false" && [ "$LATEST_ARCH_LINUX_NEWS_DATE" != "$(print_news_value 1 1)" ] && unread_news="true"

        # Print news
        for ((i = 1; i <= NEWS_QUANTITY; i++)); do
            [ "$i" = "1" ] && [ "$unread_news" = "true" ] && print_info_bold "$(print_news_value "$i" 1) | $(print_news_value "$i" 3)" && continue
            print_mesg "$(print_news_value "$i" 1) | $(print_news_value "$i" 3)"
        done

        echo # New line

        # Unread news?
        if [ $unread_news = "true" ]; then

            # Open in browser / print url (if xdg-utils is installed)
            local open_browser="false"
            command -v /usr/bin/xdg-open &>/dev/null && gum_confirm "Open in Browser?" && open_browser="true"
            [ $open_browser = "true" ] && xdg-open "$(print_news_value 1 2)" &>/dev/null
            [ $open_browser = "false" ] && print_warn "Please open: $(print_news_value 1 2)" && echo

            # Finish
            ! gum_confirm "Have you read the News?" && return 0
            LATEST_ARCH_LINUX_NEWS_DATE="$(print_news_value 1 1)" && persist_state
        fi
    fi

    return 0
}

# -------------------------------------------------------------------

show_update_info() { # Show package updates
    print_title "Update Information"

    # Sync db
    print_no_internet_info || return 3
    [ "$1" != "--no-sync" ] && ! gum_spin --title 'Synchronize Update Database...' -- bash -c "${SELF} --sync updates" && print_fail "Synchronize Database (updates) failed" && return 3

    # Check if updates available
    if ! [ -s "$UPDATES_DB" ]; then
        print_info "Your system is up to date"
        return 0
    fi

    # Check max length
    local manager_length=0 pkg_length=0 version_length=0 update_length=0
    while IFS=',' read -r manager package version update; do
        [ "${#manager}" -gt "$manager_length" ] && manager_length="${#manager}"
        [ "${#package}" -gt "$pkg_length" ] && pkg_length="${#package}"
        [ "${#version}" -gt "$version_length" ] && version_length="${#version}"
        [ "${#update}" -gt "$update_length" ] && update_length="${#update}"
    done <"$UPDATES_DB"

    # Print updates
    while IFS=',' read -r manager package version update; do
        printf "${COLOR_BOLD_BASH}:: ${COLOR_BOLD_BASH}%-${pkg_length}s  ${COLOR_RESET_BASH}%-${version_length}s  %-3s  ${COLOR_BOLD_BASH}${COLOR_GREEN_BASH}%-${update_length}s  ${COLOR_RESET_BASH}${COLOR_BOLD_BASH}%-s  ${COLOR_RESET_BASH}%-${manager_length}s\n" \
            "$package" "$version" "➜" "$update" "∷" "$manager" # ⟲ ⥄ ⇦ ➤ ➜ ≣
    done <"$UPDATES_DB"
}

# -------------------------------------------------------------------

show_health_info() { # Show system health information
    print_title "System Health"

    # Sync db
    local sync_actions=()
    #[ "$1" = "--sync-updates" ] && sync_actions+=(updates)
    [ ! -f "$PACKAGES_DB" ] && sync_actions+=(packages)
    print_no_internet_info || return 3
    [ -n "${sync_actions[*]}" ] && ! gum_spin --title 'Synchronize Database...' -- bash -c "${SELF} --sync ${sync_actions[*]}" && print_fail "Synchronize Database (updates, packages) failed" && return 3

    # Package info
    print_format_white 18 "Arch Packages" "$(pacman -Qn | wc -l)"
    [ "$AUR_SUPPORT" = "true" ] && print_format_white 18 "AUR Packages" "$(/usr/bin/paru -Qm &>/dev/null && /usr/bin/paru -Qm | wc -l || echo Error)"
    # flatpak list --columns=application | tail -n +1 | wc -l
    [ "$FLATPAK_SUPPORT" = "true" ] && print_format_white 18 "Flatpak Packages" "$(flatpak list --app | wc -l)"

    # Gnome extensions count
    command -v /usr/bin/gnome-extensions &>/dev/null && print_format_white 18 "GNOME Extensions" "$(gnome-extensions list --enabled | wc -l)"

    # Services count
    print_format_white 18 "Running Services" "$(print_service_running | wc -l)"

    # Service Failure
    service_count=$(print_service_failed | wc -l)
    if [ "$service_count" -gt "0" ]; then
        print_format_red 18 "Service Failure" "${service_count}"
    else
        print_format_green 18 "Service Failure" "${service_count}"
    fi

    # System Log
    if [ "$SHOW_SYSTEM_LOG" = "true" ]; then
        log_count=$(print_system_error_logs | wc -l)
        if [ "$log_count" -gt "0" ]; then
            print_format_yellow 18 "System Log" "${log_count}"
        else
            print_format_green 18 "System Log" "${log_count}"
        fi
    fi

    # Check pending updates
    local pending_updates=0
    [ -s "$UPDATES_DB" ] && pending_updates=$(wc -l <"$UPDATES_DB")
    if [ "$pending_updates" -gt "0" ]; then
        print_format_yellow 18 "Pending Updates" "${pending_updates}"
    else
        print_format_green 18 "Pending Updates" "${pending_updates}"
    fi

    # Check pacdiff
    local pacdiff_info pacdiff_count
    pacdiff_info="$(pacdiff -o)"
    [ -n "$pacdiff_info" ] && pacdiff_count="$(echo "$pacdiff_info" | wc -l)"
    [ -z "$pacdiff_info" ] && pacdiff_count="0"
    if [ "$pacdiff_count" -gt "0" ]; then
        print_format_yellow 18 "Pending Merges" "${pacdiff_count}"
    else
        print_format_green 18 "Pending Merges" "${pacdiff_count}"
    fi

    # Check orphans
    local orphans_packages orphans_count
    local pkg_manager="/usr/bin/pacman" && [ "$AUR_SUPPORT" = "true" ] && pkg_manager="/usr/bin/paru"
    orphans_packages="$($pkg_manager -Qtdq &>/dev/null && $pkg_manager -Qtdq)"
    orphans_count="$(echo "$orphans_packages" | wc -w)"
    if [ "$orphans_count" -gt "0" ]; then
        print_format_yellow 18 "Orphaned Packages" "${orphans_count}"
    else
        print_format_green 18 "Orphaned Packages" "${orphans_count}"
    fi

    # Unknown pkgs
    local unknown_pkgs=()
    while read -r pkg; do if ! grep -q "$pkg" "$PACKAGES_DB"; then unknown_pkgs+=("$pkg"); fi; done < <(pacman -Qqm)
    if [ -n "${unknown_pkgs[*]}" ]; then
        if [ "$SHOW_UNKNOWN_PKG_LIST" = "true" ]; then
            unknown_pkgs=$(printf "%s, " "${unknown_pkgs[@]}")
            unknown_pkgs=${unknown_pkgs%, }
            local IFS=', ' && print_format_yellow 18 "Unknown Packages" "${unknown_pkgs}"
        else
            local IFS=', ' && print_format_yellow 18 "Unknown Packages" "${#unknown_pkgs[*]}"
        fi
    else
        print_format_green 18 "Unknown Packages" "${#unknown_pkgs[*]}"
    fi
}

# ///////////////////////////////////////////////////////////////////
# SEARCH
# ///////////////////////////////////////////////////////////////////

# shellcheck disable=SC2086
show_search() { # Search & manage packages

    local search_filter pkg_name pkg_info_remote pkg_info_local pkg_is_aur pkg_is_installed
    while (true); do

        # Select package if not exists
        if [ -z "$pkg_name" ]; then

            print_header && print_title "Search Package Database"

            # Sync db
            print_no_internet_info || return 3
            [ ! -f "$PACKAGES_DB" ] && ! gum_spin --title 'Synchronize Package Database...' -- bash -c "${SELF} --sync packages" && print_fail "Synchronize Database (packages) failed" && return 3

            # Helper
            list_results() {
                local pkg_manager pkg_manager_result
                pkg_manager="/usr/bin/pacman" && [ "$AUR_SUPPORT" = "true" ] && pkg_manager="/usr/bin/paru"
                ! pkg_manager_result="$(LANG=en_US.UTF-8 $pkg_manager -Ss $1)" && return 1
                local pkg_name pkg_desc
                echo "$pkg_manager_result" | while IFS= read -r line; do
                    if [ -z "$pkg_name" ]; then
                        pkg_name="$(echo -e "$line" | cut -d ' ' -f 1)"
                    else
                        pkg_desc=$(echo "${line}" | awk '{$1=$1; print}')
                        echo -e "${pkg_name}: ${pkg_desc}" | awk '{print (length($0) > 110 ? substr($0, 1, 110) "..." : $0)}' # Cut after 110 chars and print
                        unset pkg_name
                    fi
                done
            }

            # -------------------------------------------------------------------

            # Search filter
            ! search_filter=$(gum_input --placeholder="Full-text search...") && print_warn "Canceled" && return 2
            [ -z "$search_filter" ] && print_fail "Search was empty" && return 3

            # Filter results
            local filter_pkgs_results && ! filter_pkgs_results="$(list_results "$search_filter" | tac)"
            [ -z "$filter_pkgs_results" ] && print_warn "No Results" && return 3

            print_format_green 11 "Search Filter" "$search_filter"

            mapfile -t search_result_array < <(echo "$filter_pkgs_results")
            ! pkg_name=$(gum_filter --limit 1 --height "20" --placeholder "Package..." "${search_result_array[@]}") && print_warn "Canceled" && return 2

            # Set package name
            pkg_name="$(echo "$pkg_name" | cut -d':' -f1 | cut -d'/' -f2)"
        fi

        clear_screen && print_header
        print_title "Package Information"

        # -------------------------------------------------------------------

        # Helper function
        print_package_value() {
            local result && result="$(echo "$1" | grep -i "^${2}" | sed -E "s/^${2}\s*:\s*//" || echo "unavailable")"
            echo "$result" | awk '{print (length($0) > 110 ? substr($0, 1, 110) "..." : $0)}' # Cut after 110 chars and print
        }

        # Fetch general package infos
        local pkg_manager="/usr/bin/pacman" && [ "$AUR_SUPPORT" = "true" ] && pkg_manager="/usr/bin/paru"
        pkg_info_remote="$(LANG=en_US.UTF-8 $pkg_manager -Si $pkg_name)" # Uninstalled
        pkg_is_aur="false" && [ "$(print_package_value "$pkg_info_remote" "Repository")" = "aur" ] && pkg_is_aur="true"
        pkg_is_installed="false" && /usr/bin/pacman -Q $pkg_name &>/dev/null && pkg_is_installed="true"

        # Get installed package info
        if [ "$pkg_is_installed" = "true" ]; then
            pkg_info_local="$(LANG=en_US.UTF-8 $pkg_manager -Qi $pkg_name)" # Installed
        fi

        # Print general package info
        local pkg_text && pkg_text="${pkg_name}:$(print_package_value "$pkg_info_remote" "Version")"
        print_format_white 18 "$(print_filled_space "Package")" "$pkg_text"
        print_format_white 18 "$(print_filled_space "Description")" "$(print_package_value "$pkg_info_remote" "Description")"
        # Repo
        local pkg_repo && pkg_repo="$(print_package_value "$pkg_info_remote" "Repository")"
        if [ "$pkg_repo" = "core" ] || [ "$pkg_repo" = "extra" ]; then
            print_format_white 18 "$(print_filled_space "Repository")" "$pkg_repo"
        else
            print_format_yellow 18 "$(print_filled_space "Repository")" "$pkg_repo"
        fi
        print_format_white 18 "$(print_filled_space "Dependencies")" "$(print_package_value "$pkg_info_remote" "Depends On" | wc -w)"

        # Repo Info
        if [ "$pkg_is_aur" = "true" ]; then # AUR package info
            print_format_white 18 "$(print_filled_space "AUR URL")" "$(print_package_value "$pkg_info_remote" "AUR URL")"
            print_format_white 18 "$(print_filled_space "AUR Maintainer")" "$(print_package_value "$pkg_info_remote" "Maintainer")"
            print_format_white 18 "$(print_filled_space "AUR Votes")" "$(print_package_value "$pkg_info_remote" "Votes")"
            print_format_white 18 "$(print_filled_space "AUR Popularity")" "$(print_package_value "$pkg_info_remote" "Popularity")"
            print_format_white 18 "$(print_filled_space "AUR Modified")" "$(print_package_value "$pkg_info_remote" "Last Modified" | date -f - "+%Y-%m-%d %H:%M")"

            # Check outdated packages
            local outdated && outdated="$(print_package_value "$pkg_info_remote" "Out Of Date")"
            [ "$outdated" = "No" ] && print_format_white 18 "$(print_filled_space "AUR Outdated")" "no"
            [ "$outdated" != "No" ] && print_format_red 18 "$(print_filled_space "AUR Outdated")" "$(echo "$outdated" | date -f - "+%Y-%m-%d %H:%M")"

        else
            # Non AUR package info
            print_format_white 18 "$(print_filled_space "Package URL")" "$(print_package_value "$pkg_info_remote" "URL")"
            print_format_white 18 "$(print_filled_space "Package Date")" "$(print_package_value "$pkg_info_remote" "Build Date" | date -f - "+%Y-%m-%d %H:%M")"
        fi

        # Installed/Not installed package info
        if [ "$pkg_is_installed" = "true" ]; then # Installed package info
            print_format_white 18 "$(print_filled_space "Install Date")" "$(print_package_value "$pkg_info_local" "Install Date" | date -f - "+%Y-%m-%d %H:%M")"
            print_format_white 18 "$(print_filled_space "Install Version")" "$(print_package_value "$pkg_info_local" "Version")"
            print_format_white 18 "$(print_filled_space "Install Reason")" "$(print_package_value "$pkg_info_local" "Install Reason")"
            print_format_green 18 "$(print_filled_space "Installed")" "yes"
        else # Not installed package info
            print_format_yellow 18 "$(print_filled_space "Installed")" "no"
        fi

        # Show package options menu
        echo && print_title "Options"
        # Dynamic package entries
        local options=()
        [ "$pkg_is_aur" = "true" ] && [ "$AUR_SUPPORT" = "true" ] && options+=("Show PKGBUILD")
        [ "$pkg_is_installed" = "false" ] && options+=("Install")
        [ "$pkg_is_installed" = "true" ] && options+=("Remove")
        # Show downgrade entry if package is installed and not from AUR
        command -v /usr/bin/downgrade &>/dev/null && [ "$pkg_is_installed" = "true" ] && [ "$pkg_is_aur" = "false" ] && options+=("Downgrade")
        options+=("Done")
        # Show menu
        local user_input=''
        ! user_input=$(gum_choose --selected="Done" --height=6 "${options[@]}") && print_warn "Canceled" && return 2
        case "$user_input" in # Set user action to selected action
        'Install')
            ! gum_confirm "Install?" && clear_screen && continue
            local pkg_manager_args=()
            [ "$ARCH_DOWNLOAD_TIMEOUT" = "false" ] && pkg_manager_args+=('--disable-download-timeout')
            if [ "$pkg_is_aur" = "true" ]; then
                [ "$AUR_REVIEW" = "false" ] && pkg_manager_args+=('--skipreview')
                if /usr/bin/paru -Sq "${pkg_manager_args[@]}" $pkg_name; then print_info "Install successful"; else print_fail "Installing ${pkg_name} failed"; fi
            else
                if sudo /usr/bin/pacman -Sq "${pkg_manager_args[@]}" $pkg_name; then print_info "Install successful"; else print_fail "Installing ${pkg_name} failed"; fi
            fi
            ;;
        'Remove')
            ! gum_confirm "Remove?" && clear_screen && continue
            if sudo /usr/bin/pacman -Rns $pkg_name; then print_info "Remove successful"; else print_fail "Removing ${pkg_name} failed"; fi
            ;;
        'Show PKGBUILD')
            clear_screen && print_header && print_title "PKGBUILD"
            /usr/bin/paru -Gp $pkg_name
            ;;
        'Downgrade')
            ! gum_confirm "Downgrade?" && clear_screen && continue
            if sudo downgrade $pkg_name; then print_info "Downgrade successful"; else print_fail "Downgrading ${pkg_name} failed"; fi
            ;;
        'Done') print_mesg "Done" && return 2 ;;
        *) unset pkg_name && print_fail "Action '${user_input}' not available" && return 3 ;;
        esac
        gum_confirm_continue
        clear_screen
    done
    return 0
}

# ///////////////////////////////////////////////////////////////////
# DASHBOARD
# ///////////////////////////////////////////////////////////////////

show_dashboard() { # Dashboard
    local options user_input system_logs
    if [ "$SHOW_SYSTEM_LOG" = "true" ]; then
        # Show system logs
        print_title "System Log"
        system_logs=$(print_system_error_logs)
        if [ -n "$system_logs" ]; then
            local log_counter=0
            echo -e "$system_logs" | while read -r line; do print_fail "$line" && ((log_counter++)) && [ $log_counter -gt 25 ] && echo && print_warn "You have more than 25 Logs. Output stopped..." && break; done
        else
            print_info "No System Log available"
        fi
        echo # Print new line
    fi

    # Show service health
    [ "$SHOW_SERVICE_LIST" = "true" ] && print_title "Service Information" && print_service_running | while read -r line; do echo "${line}"; done && echo

    # Failed services
    services_failed="$(print_service_failed)"
    if [ -n "$services_failed" ]; then
        print_title "Failed Services" && echo -e "$services_failed" | while read -r line; do echo "${line}"; done && echo
    fi

    show_update_info
    echo # Newline
    show_health_info

    local pending_updates
    [ -s "$UPDATES_DB" ] && pending_updates=$(wc -l <"$UPDATES_DB")

    # Show options menu
    echo && print_title "Options"
    options=()
    options+=("Edit Blacklist")
    [ "$pending_updates" -gt "0" ] && options+=("Upgrade")
    options+=("Done")
    ! user_input=$(gum_choose --height=6 --selected="Done" "${options[@]}") && print_warn "Canceled" && return 2
    case "$user_input" in
    'Edit Blacklist')
        clear_screen && print_header && print_title "Edit Blacklist"
        local line_count && line_count=$(wc -l <"${ARCH_OS_BLACKLIST}") # Count properties by line
        # Open editor with count of properties + 2
        # BUG: gum write does not accept height greater than 7
        if gum_write --show-line-numbers --height="$((line_count + 2))" --placeholder="Add log message snippet to hide in system log view (line by line)..." --value="$(<"$ARCH_OS_BLACKLIST")" >"${ARCH_OS_BLACKLIST}.new"; then
            # If success: save/move file, remove spaces and re-init properties
            awk '{$1=$1; print}' "${ARCH_OS_BLACKLIST}.new" >"$ARCH_OS_BLACKLIST" && init_properties && persist_properties || return 1
            rm -f "${ARCH_OS_BLACKLIST}.new"
            print_info "Saved" && return 0
        else
            rm -f "${ARCH_OS_BLACKLIST}.new" # Remove tmp properties
            print_warn "Canceled" && return 3
        fi
        ;;
    'Upgrade')
        clear_screen && print_header
        show_upgrade
        return 2
        ;;
    'Done') print_mesg "Done" && return 2 ;;
    *) print_fail "Option '${user_input}' not available" && return 3 ;;
    esac
    return 0
}

# ///////////////////////////////////////////////////////////////////
# UPGRADE
# ///////////////////////////////////////////////////////////////////

show_upgrade() { # Update packages

    # Show infos
    show_news_info || return $?
    show_update_info || return $?
    echo && show_health_info || return $?
    if [ ! -s "$UPDATES_DB" ]; then
        gum_confirm_continue
        return 2
    fi

    # Start upgrade system
    echo && ! gum_confirm "Start System Upgrade?" && return 2
    clear_screen && print_header && print_title "Upgrade System Packages"

    # Prepare args
    local pkg_manager_args=()
    [ "$ARCH_DOWNLOAD_TIMEOUT" = "false" ] && pkg_manager_args+=('--disable-download-timeout')
    [ "$ARCH_UPGRADE_CONFIRM" = "false" ] && pkg_manager_args+=('--noconfirm')

    # Upgrade system packages
    ! sudo /usr/bin/pacman -Syuq "${pkg_manager_args[@]}" && print_fail "System Upgrade failed" && return 3

    # Upgrade AUR packages
    if [ "$AUR_SUPPORT" = "true" ]; then
        print_info "Upgrading AUR Packages..."
        [ "$AUR_REVIEW" = "false" ] && pkg_manager_args+=('--skipreview')
        ! /usr/bin/paru -Suaq "${pkg_manager_args[@]}" && print_fail "AUR Upgrade failed" && return 3
    fi

    # Upgrade flatpak packages
    if [ "$FLATPAK_SUPPORT" = "true" ]; then
        if [ -n "$(flatpak remote-ls --updates)" ]; then      # Check if flatpak updates available
            if [ "$FLATPAK_UPGRADE_CONFIRM" = "false" ]; then # Do auto flatpak update
                ! gum_spin --title 'Upgrading Flatpak Apps...' -- bash -c "flatpak update -y --noninteractive" && print_fail "Flatpak Upgrade failed" && return 3
            else # Do Interactive flatpak update
                print_info "Upgrading Flatpak Apps" && ! flatpak update && print_fail "Flatpak Upgrade failed" && return 3
            fi
            print_info "Flatpak Upgrade finished"
        else # Up to date
            print_info "Flatpak is up to date"
        fi
    fi

    # Resync packages & updates db
    print_no_internet_info || return 3
    ! gum_spin --title 'Synchronize Update Database...' -- bash -c "${SELF} --sync packages updates" && print_fail "Synchronize Database failed" && return 3

    # Finish
    LATEST_SYSTEM_UPGRADE="$(print_timestamp)" && persist_state
    print_info "System Upgrade finished"
    echo # Print new line
    show_health_info || return $?
    return 0
}

# ///////////////////////////////////////////////////////////////////
# ORPHANS
# ///////////////////////////////////////////////////////////////////

show_orphans() { # Remove orphaned packages
    print_title "Remove Package Orphans"
    ! gum_confirm "Continue?" && return 2
    local pkg_manager_args=() && [ "$ORPHANS_CONFIRM" = "false" ] && pkg_manager_args+=('--noconfirm')
    # Remove pacman orphans
    # Alternative: ! sudo /usr/bin/pacman -Rsu --noconfirm $(/usr/bin/pacman -Qqd) 2>/dev/null && print_fail "Failed" && return 3
    # shellcheck disable=SC2046
    if /usr/bin/pacman -Qtdq &>/dev/null; then
        ! sudo /usr/bin/pacman -Rns "${pkg_manager_args[@]}" $(/usr/bin/pacman -Qtdq) && print_fail "Remove System Orphans failed" && return 3
    else
        print_info "No orphaned system packages found"
    fi
    # Remove unused flatpaks
    if [ "$FLATPAK_SUPPORT" = "true" ]; then
        if [ "$ORPHANS_CONFIRM" = "false" ]; then # Do auto flatpak orphans
            ! gum_spin --title 'Removing Flatpak Orphans...' -- bash -c "flatpak uninstall -y --noninteractive --unused" && print_fail "Remove Flatpak Orphans failed" && return 3
            print_info "Remove Flatpak Orphans finished"
        else # Do Interactive flatpak orphans
            print_info "Remove Flatpak Orphans" && ! flatpak uninstall --unused && print_fail "Remove Flatpak Orphans failed" && return 3
        fi
    fi
    print_info "Done"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# MERGE
# ///////////////////////////////////////////////////////////////////

show_merge() { # Merge updated config files
    if ! command -v /usr/bin/pacdiff &>/dev/null || ! command -v meld &>/dev/null; then
        print_title "Install Pacdiff Tools"
        ! gum_confirm "Continue?" && return 2
        local pkg_manager_args=()
        [ "$ARCH_DOWNLOAD_TIMEOUT" = "false" ] && pkg_manager_args+=('--disable-download-timeout')
        ! sudo /usr/bin/pacman -Sq --needed "${pkg_manager_args[@]}" meld && print_warn "Canceled" && return 3
        # Hide meld app
        if gum_confirm "Hide App Icon in GNOME Menu?"; then
            echo -e '[Desktop Entry]\nType=Application\nHidden=true' >"${HOME}/.local/share/applications/org.gnome.Meld.desktop"
        else
            rm -f "${HOME}/.local/share/applications/org.gnome.Meld.desktop"
        fi
        clear_screen && print_header # Clean install output & print new header
    fi
    print_title "Merge Pacdiff Configurations"
    ! gum_confirm "Continue?" && return 2
    # List & show pacdiff config files
    local pacdiff_files=() && while IFS= read -r line; do pacdiff_files+=("$line"); done < <(pacdiff -o)
    [ ${#pacdiff_files[@]} -eq 0 ] && print_info "Nothing to do" && return 0
    for file in "${pacdiff_files[@]}"; do print_warn "$file"; done
    # Merge files
    echo && ! sudo DIFFPROG=meld pacdiff && echo -e '\n' && print_warn "Canceled" && return 3
    print_info "Done"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# REFRESH
# ///////////////////////////////////////////////////////////////////

show_refresh() { # Refresh mirrorlist with reflector
    if ! command -v /usr/bin/reflector &>/dev/null; then
        print_title "Install Reflector" # Install missing pkgs
        ! gum_confirm "Continue?" && return 2
        local pkg_manager_args=()
        [ "$ARCH_DOWNLOAD_TIMEOUT" = "false" ] && pkg_manager_args+=('--disable-download-timeout')
        ! sudo /usr/bin/pacman -Sq --needed "${pkg_manager_args[@]}" reflector && print_warn "Canceled" && return 3
        clear_screen && print_header # Clean install output & print new header
    fi
    print_title "Refresh Pacman Mirrorlist"
    ! gum_confirm "Continue?" && return 2
    # Refresh mirrorlist with reflector and return if user press ctrl + c
    ! gum_spin --title 'Waiting for Reflector...' -- bash -c "reflector --latest 5 --protocol https --sort rate --save $MIRRORLIST_TMP &> /dev/null; wait; exit 0" && print_fail "Failed" && return 3
    # Clean reflector result (list only servers)
    local mirrorlist_cleaned && mirrorlist_cleaned=$(grep -v '^#' "$MIRRORLIST_TMP" | sed '/^$/d;s/^[[:space:]#]*//')
    echo -e "$mirrorlist_cleaned" >"$MIRRORLIST_TMP"
    ! [ -s "$MIRRORLIST_TMP" ] && print_fail "New mirrorlist is empty" && return 3
    # Print cleaned mirrorlist
    while IFS= read -r line || [ -n "$line" ]; do print_info "$line"; done < <(cat "$MIRRORLIST_TMP")
    # Edit mirrorlist?
    echo && gum_confirm "Edit Mirrorlist?" && clear_screen && print_header && print_title "New Mirrorlist" && if gum_write --show-line-numbers --height="6" --value="$(cat "$MIRRORLIST_TMP")" >"${MIRRORLIST_TMP}.new"; then
        # Refresh & re-print new mirrorlist
        mv -f "${MIRRORLIST_TMP}.new" "$MIRRORLIST_TMP"
        while IFS= read -r line || [[ -n "$line" ]]; do print_info "$line"; done < <(cat "$MIRRORLIST_TMP") && echo
    else
        rm -f "${MIRRORLIST_TMP}.new"
        while IFS= read -r line || [[ -n "$line" ]]; do print_info "$line"; done < <(cat "$MIRRORLIST_TMP") && echo
        print_warn "Edit canceled"
    fi
    # Save mirrorlist?
    ! gum_confirm "Save Mirrorlist?" && print_warn "New mirrorlist was ignored" && return 2
    # Check new mirrorlist
    ! [ -s "$MIRRORLIST_TMP" ] && print_fail "New mirrorlist is empty" && return 3
    # Save mirrorlist and set correct permissions
    sudo cp -f "$MIRRORLIST_TMP" /etc/pacman.d/mirrorlist
    sudo chown root:root /etc/pacman.d/mirrorlist
    print_info "Successfully copied to /etc/pacman.d/mirrorlist"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# DOWNGRADE
# ///////////////////////////////////////////////////////////////////

show_downgrade() { # Downgrade packages
    if ! command -v /usr/bin/downgrade &>/dev/null; then
        [ "$AUR_SUPPORT" = "false" ] && print_fail "AUR Helper is missing. The package 'downgrade' can not be installed" && return 3
        print_title "Install Downgrade"
        ! gum_confirm "Continue?" && return 2
        local pkg_manager_args=()
        [ "$ARCH_DOWNLOAD_TIMEOUT" = "false" ] && pkg_manager_args+=('--disable-download-timeout')
        [ "$AUR_SUPPORT" = "true" ] && [ "$AUR_REVIEW" = "false" ] && pkg_manager_args+=('--skipreview')
        ! /usr/bin/paru -Sq --needed "${pkg_manager_args[@]}" downgrade && print_warn "Canceled" && return 3
        clear_screen && print_header # Clean install output & print new header
    fi
    print_title "Downgrade Pacman Packages"
    local user_input options
    mapfile -t options < <(pacman -Qqn | uniq) # Only packages from official db
    ! user_input=$(gum_filter --limit 25 --height "20" --placeholder "Type to filter and toggle with CTRL + Space..." "${options[@]}") && return 2
    [ -z "$user_input" ] && print_warn "No package selected" && return 3
    mapfile -t user_input <<<"$user_input" # Convert string to array
    # Print packages
    for item in "${user_input[@]}"; do print_warn "${item}"; done
    echo && ! gum_confirm "Downgrade selected packages?" && return 2
    ! sudo downgrade "${user_input[@]}" && print_warn "Canceled" && return 3
    print_info "Downgrade successful"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# CLEAR CACHE
# ///////////////////////////////////////////////////////////////////

show_clear_cache() { # Clear package cache
    print_title "Clear Package Cache"
    ! gum_confirm "Continue?" && return 2
    local pkg_manager="sudo /usr/bin/pacman" && [ "$AUR_SUPPORT" = "true" ] && pkg_manager="/usr/bin/paru"
    $pkg_manager -Scc
    return 0
}

# ///////////////////////////////////////////////////////////////////
# RESET PACMAN
# ///////////////////////////////////////////////////////////////////

show_reset_pacman() { # Reset Pacman (if update failed, try to reset & reinit keyring)
    print_title "Reset Pacman Keyring"
    ! gum_confirm "Continue?" && return 2
    sudo rm -f /var/lib/pacman/db.lck # Remove pacman lock if exists
    # Keyring reset
    ! sudo rm -rf /etc/pacman.d/gnupg && print_fail "Failed" && return 3
    ! sudo pacman-key --init && print_fail "Failed" && return 3
    ! sudo pacman-key --populate && print_fail "Failed" && return 3
    # Update Arch keyring & system
    local pkg_manager_args=()
    [ "$ARCH_DOWNLOAD_TIMEOUT" = "false" ] && pkg_manager_args+=('--disable-download-timeout')
    [ "$ARCH_UPGRADE_CONFIRM" = "false" ] && pkg_manager_args+=('--noconfirm')
    ! sudo /usr/bin/pacman -Syyq --noconfirm archlinux-keyring && sudo /usr/bin/pacman -Suq "${pkg_manager_args[@]}" && print_warn "Canceled" && return 3
    print_info "Done"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# SETTINGS
# ///////////////////////////////////////////////////////////////////

show_config() { # Config
    print_title "Edit Config"
    local line_count && line_count=$(wc -l <"${ARCH_OS_CONF}") # Count properties by line
    # Open editor with count of properties + 2
    # BUG: gum write does not accept height greater than 7
    if gum_write --show-line-numbers --height="$((line_count + 2))" --value="$(<"$ARCH_OS_CONF")" >"${ARCH_OS_CONF}.new"; then
        # If success: save/move file and re-init properties
        mv "${ARCH_OS_CONF}.new" "${ARCH_OS_CONF}" && init_properties && persist_properties
        print_no_internet_info || return 3
        ! gum_spin --title 'Synchronize Database...' -- bash -c "${SELF} --sync news packages" && print_fail "Synchronize Database failed" && return 3
        print_info "Saved" && return 0
    else
        rm -f "${ARCH_OS_CONF}.new" # Remove tmp properties
        print_warn "Canceled" && return 3
    fi
}

# ///////////////////////////////////////////////////////////////////
# HELP
# ///////////////////////////////////////////////////////////////////

show_help() { # Print help page
    print_title 'GitHub'
    print_mesg 'https://github.com/murkl/arch-os-manager' && echo
    print_title 'Usage'
    print_info_bold 'arch-os [--kitty | -k] [action]' && echo
    print_title 'App Actions'
    print_mesg 'help             ➜  Open help page'
    print_mesg 'version          ➜  Print version info'
    print_mesg 'config           ➜  Edit config in built-in ediitor' && echo
    print_title 'System Actions'
    print_mesg 'check            ➜  Print package updates (checkupdates)'
    print_mesg 'notify           ➜  Notify on new package updates (autostart)'
    print_mesg 'dashboard        ➜  Show dashboard (logs, services, health)'
    print_mesg 'info             ➜  Show system update info (without database sync)'
    print_mesg 'upgrade          ➜  System upgrade (news, health, pacman, aur, flatpak)'
    print_mesg 'pkg              ➜  Search & manage packages (pacman, aur)'
    print_mesg 'orphans          ➜  Remove orphaned packages (pacman, aur, flatpak)'
    print_mesg 'merge            ➜  Merge updated configurations (pacdiff, meld)'
    print_mesg 'refresh          ➜  Refresh & edit pacman mirrorlist (reflector)'
    print_mesg 'downgrade        ➜  Downgrade packages (pacman)'
    print_mesg 'cache            ➜  Clear package cache (pacman, aur)'
    print_mesg 'reset            ➜  Reset pacman keyring & upgrade (pacman)'
}

# ///////////////////////////////////////////////////////////////////
# VERSION
# ///////////////////////////////////////////////////////////////////

show_version() { # Print version page
    print_title "Version Information"
    print_mesg "$(kitty --version)"
    print_mesg "$(gum --version)"
    print_mesg "$(notify-send --version)"
    [ "$FLATPAK_SUPPORT" = "true" ] && print_mesg "$(flatpak --version)"
    [ "$AUR_SUPPORT" = "true" ] && print_mesg "$(/usr/bin/paru --version)"
    print_mesg "$(/usr/bin/checkupdates --version)"
    /usr/bin/pacman --version
    return 0
}

# ///////////////////////////////////////////////////////////////////
# PRINT HELPER FUNCTIONS
# ///////////////////////////////////////////////////////////////////

print_header() {
    if [ "$HEADER_PRINTED" = "false" ]; then
        clear && printf '\e[3J' && gum_purple '
 █████  ██████   ██████ ██   ██      ██████  ███████ 
██   ██ ██   ██ ██      ██   ██     ██    ██ ██      
███████ ██████  ██      ███████     ██    ██ ███████ 
██   ██ ██   ██ ██      ██   ██     ██    ██      ██ 
██   ██ ██   ██  ██████ ██   ██      ██████  ███████
    ' && gum_white --bold "System Manager ${VERSION}" && echo
        HEADER_PRINTED="true"
    fi
}

print_filled_space() {
    local total=24
    [ -n "$2" ] && total="$1" && shift # Check if total spaces is set
    local input_string="$1" && local length="${#input_string}"
    if [ "$length" -ge "$total" ]; then
        echo "$input_string"
    else
        local padding=$((total - length))
        printf '%s%*s\n' "$input_string" "$padding" ""
    fi
}

# System
notify_send() { notify-send --app-name "Arch OS Manager" -i "${WORKING_DIR}/docs/logo.svg" "$1" "$2" || return 0; }
clear_screen() { clear && printf '\e[3J' && HEADER_PRINTED="false"; } # Clear and remove scrollback buffer

# Gum wrapper
gum() { "$GUM" "$@"; }
gum_style() { gum style "${@}"; }
gum_join() { gum join "${@}"; }
gum_filter() { gum filter --width="120" --prompt " > " --indicator " >" --header.foreground "$COLOR_PURPLE" "${@}"; }
gum_write() { gum write --width="120" --char-limit 0 "${@}"; }
gum_choose() { gum choose --no-show-help --header="" --cursor " > " "${@}"; }
gum_input() { gum input --no-show-help --prompt " > " --prompt.foreground "$COLOR_PURPLE" --header.foreground "$COLOR_PURPLE" "${@}"; }
gum_spin() { gum spin --spinner dot "${@}"; }
gum_confirm() { gum confirm --no-show-help --prompt.foreground "$COLOR_PURPLE" "$@"; }
gum_confirm_continue() { echo && gum choose --no-show-help --header="" --cursor "" "Press <Enter> to continue..." | cat >/dev/null; }

# Gum colors
gum_white() { gum_style --foreground "$COLOR_WHITE" "${@}"; }
gum_purple() { gum_style --foreground "$COLOR_PURPLE" "${@}"; }

# Print helper
print_title() { gum_join "$(gum_purple --bold "// ")" "$(gum_purple --bold "${*}")"; }
print_info_bold() { printf "${COLOR_BOLD_BASH}${COLOR_GREEN_BASH}%s ${COLOR_RESET_BASH}${COLOR_BOLD_BASH}%s${COLOR_RESET_BASH}\n" "::" "$*"; }
print_info() { printf "${COLOR_BOLD_BASH}${COLOR_GREEN_BASH}%s ${COLOR_RESET_BASH}%s${COLOR_RESET_BASH}\n" "::" "$*"; }
print_warn() { printf "${COLOR_BOLD_BASH}${COLOR_YELLOW_BASH}%s ${COLOR_RESET_BASH}%s${COLOR_RESET_BASH}\n" "::" "$*"; }
print_fail() { printf "${COLOR_BOLD_BASH}${COLOR_RED_BASH}%s ${COLOR_RESET_BASH}%s${COLOR_RESET_BASH}\n" "::" "$*"; }
print_mesg() { printf "${COLOR_BOLD_BASH}${COLOR_WHITE_BASH}%s ${COLOR_RESET_BASH}%s${COLOR_RESET_BASH}\n" "::" "$*"; }

# Print format | ⟲ ⥄ ⇦ ➤ ➜ ≣
print_format() { local space="$1" color="$2" key="$3" value="$4" && printf "${COLOR_BOLD_BASH}${color}%s${COLOR_RESET_BASH} %s ${COLOR_BOLD_BASH}%s ${color}%s ${COLOR_RESET_BASH}\n" "::" "$(print_filled_space "$space" "$key")" " ➜ " "$value"; }
print_format_white() { print_format "$1" "$COLOR_WHITE_BASH" "$2" "$3"; }
print_format_green() { print_format "$1" "$COLOR_GREEN_BASH" "$2" "$3"; }
print_format_yellow() { print_format "$1" "$COLOR_YELLOW_BASH" "$2" "$3"; }
print_format_red() { print_format "$1" "$COLOR_RED_BASH" "$2" "$3"; }

# ///////////////////////////////////////////////////////////////////
# KITTY FUNCTIONS
# ///////////////////////////////////////////////////////////////////

kitty() {
    [ ! -f "$ARCH_OS_KITTY_CONF" ] && echo "$kitty_conf_template" >"$ARCH_OS_KITTY_CONF" # Create kitty.conf if not exists
    "$KITTY" --detach --class "arch-os" --name "Arch OS" -c "$ARCH_OS_KITTY_CONF" "$@"
}

# https://sw.kovidgoyal.net/kitty/conf/
kitty_conf_template='
hide_window_decorations yes
remember_window_size true
initial_window_width 1080
initial_window_height 720
placement_strategy center
window_padding_width 32
font_size 10.0
active_tab_font_style bold
inactive_tab_font_style normal
foreground              #D8DEE9
background              #2E3440
selection_foreground    #3B4252
selection_background    #EBCB8B
active_tab_foreground   #2E3440
active_tab_background   #A3BE8C
inactive_tab_foreground #2E3440
inactive_tab_background #4C566A
cursor                  #D8DEE9
url_color               #81A1C1
color0                  #3B4252
color8                  #4C566A
color1                  #BF616A
color9                  #BF616A
color2                  #A3BE8C
color10                 #A3BE8C
color3                  #EBCB8B
color11                 #EBCB8B
color4                  #81A1C1
color12                 #81A1C1
color5                  #B48EAD
color13                 #B48EAD
color6                  #88C0D0
color14                 #88C0D0
color7                  #E5E9F0
color15                 #E5E9F0
'

# ///////////////////////////////////////////////////////////////////
# INSTALL SCRIPT DEPENDENCIES
# ///////////////////////////////////////////////////////////////////

install_script_dependencies() {

    # Remove tmp dir on exit
    trap 'rm -rf ${ARCH_OS_TMP}' EXIT

    # Pacman helper
    pacman_install() {
        sudo pacman -Sq --needed --disable-download-timeout "$@"
    }

    # AUR helper
    aur_install() {
        local repo_url repo_tmp_dir
        repo_url="https://aur.archlinux.org/${1}.git"
        repo_tmp_dir="${ARCH_OS_TMP}/${1}"
        git clone "$repo_url" "$repo_tmp_dir"
        cd "$repo_tmp_dir"
        echo -e "\noptions=('!debug')" >>PKGBUILD
        makepkg -si
    }

    # Install system packages
    echo ":: Install Arch OS Manager Dependencies"
    pacman_install git base-devel pacman-contrib reflector flatpak gum kitty libnotify fzf xdg-utils meld

    # Create backup
    [ -f /etc/paru.conf ] && sudo cp -f /etc/paru.conf "/etc/paru.conf.$(date +"%Y%m%d%H%M%S")"

    # Install paru
    echo ":: Install Paru..."
    aur_install "$AUR_MANGER_REPO" || return 1

    # Set paru config
    sudo sed -i 's/^#BottomUp/BottomUp/g' /etc/paru.conf
    sudo sed -i 's/^#SudoLoop/SudoLoop/g' /etc/paru.conf

    # Install downgrade
    echo ":: Install Downgrade..."
    aur_install downgrade || return 1

    echo ":: Successfully finished"
    return 0
}

# ///////////////////////////////////////////////////////////////////
# START SCRIPT
# ///////////////////////////////////////////////////////////////////

# Locating working dir
working_src=${BASH_SOURCE[0]}
while [ -L "$working_src" ]; do
    WORKING_DIR=$(cd -P "$(dirname "$working_src")" >/dev/null 2>&1 && pwd)
    working_src=$(readlink "$working_src")
    [[ $working_src != /* ]] && working_src=$WORKING_DIR/$working_src
done
WORKING_DIR=$(cd -P "$(dirname "$working_src")" >/dev/null 2>&1 && pwd)
SELF="$WORKING_DIR/$(basename "$0")"

# -------------------------------------------------------------------

main "$@" # Start main function

# -------------------------------------------------------------------
